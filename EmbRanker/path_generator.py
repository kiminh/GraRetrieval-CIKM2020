import networkx as nx
import random,tqdm
import numpy as np
import math,os,cPickle

from collections import Counter
import itertools,argparse
from config import *

def toqid(fname):
    return 'q' + fname.split('.')[0]

class PathGenerator():
    def __init__(self,config,edge_type):
        self.session_file = config['train_addr']
        self.path_length = config['path_length']
        self.edge_type = edge_type
        self.coverage = config['coverage']

        self.query_dict_addr = config['query_dict']
        self.doc_dict_addr = config['doc_dict']

        self.qid2text_dict = cPickle.load(open(self.query_dict_addr))
        self.did2text_dict = cPickle.load(open(self.doc_dict_addr))

        print len(self.qid2text_dict), len(self.did2text_dict)
        self.walks = []
        self.pairs = []


    def read_graph(self):
        if edge_type == 'term':
            self.G = cPickle.load(open('../statistic/graph/query_doc_by_term.pkl'))
        else:
            self.G = cPickle.load(open('../statistic/graph/%s.pkl' % edge_type))

    def cal_degree(self):
        degrees = [val for (node, val) in self.G.degree() if node[0] == 'q']
        return np.mean(degrees)


    def get_nodelist(self,node_type=None):
        if not node_type:
            return list(self.G.nodes)
        return [node for node in list(self.G.nodes)
                if node[0] == node_type]

    def generate_path_by_random_walk(self,):
        walks = []
        start_node_list = self.get_nodelist()#[:10]

        num_walks = self.coverage
        path_length = self.path_length

        rand = random.Random(0)

        print 'generating random walk path...'
        for cnt in tqdm.tqdm(range(num_walks)):  # Iterate the node set for cnt times
            rand.shuffle(start_node_list)
            for start_node in tqdm.tqdm(start_node_list):
                if len(list(self.G.neighbors(start_node))) != 0:
                    walks.append(self.random_walk(start_node,path_length))

        print 'Random walk path done...'

        self.walks = walks


    def random_walk(self,start,walk_length):
        G = self.G
        rand = random.Random()
        walk = [start]
        cur_node = start
        while len(walk) <= walk_length:
            possible_next_nodes = [neighbor
                                   for neighbor in G.neighbors(cur_node)]
            next_node = rand.choice(possible_next_nodes)
            walk.append(next_node)
            cur_node = next_node

        return " ".join(walk)

    def path_to_pairs(self,window_size):
        print 'path to pairs ...'
        print ('Window size: %d' % window_size)
        self.window_size = window_size

        pairs = []
        for walk in self.walks:
            walk = walk.strip().split(' ')
            for pos, token in enumerate(walk):
                lcontext, rcontext = [], []
                lcontext = walk[pos - window_size: pos] \
                    if pos - window_size >= 0 \
                    else walk[:pos]

                if pos + 1 < len(walk):
                    rcontext = walk[pos + 1: pos + window_size] \
                        if pos + window_size < len(walk) \
                        else walk[pos + 1:]

                context_pairs = [[token, context]
                                 for context in lcontext + rcontext]
                pairs += context_pairs

        np.random.shuffle(pairs)
        self.pairs = pairs

    def down_sample(self,input_pairs):
        """Down sampling the training sets

        1. Remove all the duplicate tuples
        2. Take log of all tuples as a down sampling
        """

        # = self.pairs
        pairs = [(pair[0], pair[1])
                 for pair in input_pairs
                 if pair[0] != pair[1]]
        cnt = Counter(pairs)
        down_cnt = [[pair] * int(math.ceil(math.log(count)))
                    for pair, count in cnt.items()]
        pairs = list(itertools.chain(*down_cnt))
        np.random.shuffle(pairs)

        return pairs

    def write_paths(self):
        """Write paths to files
        Args:
            walks - The walks generated by `generate_walks`
        """

        print("Writing Generated paths to files ...")

        if not os.path.exists('./data/random_walk/%s/path/' % self.edge_type):
            os.makedirs('./data/random_walk/%s/path/' % self.edge_type)
        OUTPUT = './data/random_walk/%s/path/converge%d_walklen%d.txt' % (self.edge_type, self.coverage, self.path_length)

        with open(OUTPUT, "w") as fout:
            for walk in self.walks:
                print >> fout, walk

        print("Done!")

    def write_pairs(self,pairs=None,OUTPUT=None):
        """Write all pairs to files
        Args:
            pairs - the corpus
        Return:
        """
        print("Writing Generated Pairs to files ...")

        if OUTPUT == None:
            if not os.path.exists('./data/random_walk/%s/pair/' % self.edge_type):
                os.makedirs('./data/random_walk/%s/pair/' % self.edge_type)

            OUTPUT = './data/random_walk/%s/pair/converge%d_walklen%d_winsize%d.txt' % \
                     (self.edge_type, self.coverage, self.path_length, self.window_size)
        if pairs == None:
            pairs = self.pairs

        with open(OUTPUT, "w") as fout:
            for pair in pairs:
                if pair[0][0] == 'w' or pair[1][0] == 'w':
                    continue
                print >> fout, ("{}\t{}\t{}\t{}".format(pair[0], pair[1], \
                                                        self.id2text(pair[0]),self.id2text(pair[1])))

        print("Done!")
        return

    def id2text(self,pair_id):
        return self.qid2text_dict[pair_id] if pair_id[0] == 'q' else self.did2text_dict[pair_id]


    def sampleNegativePairs(self,docRatio=1,edge_type='query_click'):
        '''
        :param pairSize: the number of pairs
        :param docRatio:
        :return:
        '''
        addr = self.session_file
        session_folders = os.listdir(addr)
        print 'session count: ', len(session_folders)
        negative_doc_pairs = []
        random_pairs = []

        if edge_type == 'query_click':
            for i, sid_name in tqdm.tqdm(enumerate(session_folders)):
                s_addr = os.path.join(addr, sid_name)
                query_files = os.listdir(s_addr)
                query_files.sort()


                for i, qfile in enumerate(query_files):
                    fname = os.path.join(s_addr, qfile)
                    for i, line in enumerate(open(fname)):
                        elements = line.strip().split('\t')
                        if i > 0 and float(elements[5]) <= 0.5:  # skip first line and choose doc with click prob <= 70% in the whole set
                            negative_doc_pairs.append((elements[0], elements[1]))  # (qid,did)

            negative_doc_pairs = self.down_sample(negative_doc_pairs)
            query_nodes = self.get_nodelist(node_type='q') * docRatio  # repeat n times
        else:
            query_nodes = self.get_nodelist(node_type=None) * docRatio #repeat n times

        #if docRatio != None:
            #np.random.shuffle(negative_doc_pairs)
        #    negative_doc_pairs = negative_doc_pairs[: int(len(query_nodes) * docRatio)]

        rand_negative_nodes = np.random.choice(np.array(self.G.nodes()), size=len(query_nodes))
        negative_random_pairs = zip(query_nodes,rand_negative_nodes)

        print 'negative_doc_pairs: ',len(negative_doc_pairs)
        print 'negative_random_pairs: ',len(negative_random_pairs)
        neg_pairs_list = list(itertools.chain(negative_doc_pairs, negative_random_pairs))

        if not os.path.exists('./data/random_walk/%s/neg_pair/' % self.edge_type):
            os.makedirs('./data/random_walk/%s/neg_pair/' % self.edge_type)
        filename = './data/random_walk/%s/neg_pair/neg_pair_docratio_%d.txt' % (self.edge_type,docRatio)

        self.write_pairs(pairs=neg_pairs_list, OUTPUT=filename)

        return

def load_arguments():
    parser = argparse.ArgumentParser(description='Path Generation Model')
    parser.add_argument("--prototype", type=str, help="Use the prototype", default='path_config')
    #parser.add_argument("--ws", type=int, help="Window size", default=1)
    parser.add_argument("--type", type=str, help="edge_type", default='query_click')
    args = parser.parse_args()

    return args


if __name__ == '__main__':
    args = load_arguments()
    config_state = eval(args.prototype)()
    edge_type = args.type

    pg = PathGenerator(config_state,edge_type)
    pg.read_graph()

    pg.generate_path_by_random_walk()

    ws_s = [3]
    for ws in ws_s:
        print 'current window size: ',ws
        pg.path_to_pairs(window_size=ws)
        pg.pairs = pg.down_sample(pg.pairs)
        pg.write_paths()
        pg.write_pairs()
        pg.sampleNegativePairs(docRatio=10)


